# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`. Обратите внимание, что `strace` выдаёт результат своей работы в поток stderr, а не в stdout.
	```
	serg@vagrant:~$ strace bash -c 'cd /tmp' 
	...
	execve("/usr/bin/bash", ["bash", "-c", "cd /tmp"], 0x7ffd312ee300 /* 17 vars */) = 0
	stat("/tmp", {st_mode=S_IFDIR|S_ISVTX|0777, st_size=4096, ...}) = 0
	chdir("/tmp")                           = 0
	...
	```
	
	
     *chdir - изменить рабочий каталог*
1. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:
    ```bash
    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
    ```
    Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки.
    ```
	serg@vagrant:~$ strace file  /dev/sda1  
	...
	openat(AT_FDCWD, "/etc/magic.mgc", O_RDONLY) = -1 ENOENT (No such file or directory)
	openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
	openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
	...
	```
	*Информация, идентифицирующая эти файлы, считывается из скомпилированного файла magic `/usr/share/file/magic.mgc->../../lib/file/magic.mgc` или `/etc/magic` , если файл компиляции не существует*
1. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

    *Смоделируем похожую ситуацию. Запустим тестовый скрипт, пишущий произвольные данные в файл test.txt рабочей директории и удалим его*
	```
	serg@vagrant:~$ ./test.py &
	[1] 5857
	serg@vagrant:~$ rm test.txt
	```
	*Вооружившись `lsof` найдем PID процесса, открывшего файл*
	
	```
	serg@vagrant:~$ lsof | grep deleted
	test.py   5857                          serg    3w      REG              253,0 227546851     131602 /home/serg/test.txt (deleted)
	```
	*Узнаем номер файлового дескриптора*
	```
	serg@vagrant:~$ ll /proc/5857/fd | grep /home/serg/test.txt
	l-wx------ 1 serg serg 64 Nov 17 12:50 3 -> /home/serg/test.txt (deleted)
	```
	*Выполним команду, чтобы освободить место на диске, которое занимает удаленный файл*
	```
	serg@vagrant:~$ truncate -s 0 /proc/5857/fd/3
	```
	*Убедимся в достигнутом результате*
	```
	serg@vagrant:~$ lsof | grep deleted
	test.py   5857                          serg    3w      REG              253,0        0     131602 /home/serg/test.txt (deleted)
	```
	
1. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
	
	*Зомби не занимают памяти , но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
	При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы. Кроме этого, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль (локальную или удалённую) или выполнить какие-либо команды на уже открытой консоли (потому что для этого командный интерпретатор sh должен создать новый процесс), и для восстановления работоспособности (завершения виновной программы) будет необходимо вмешательство системного администратора.*
1. В iovisor BCC есть утилита `opensnoop`:
    ```bash
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    ```
 
    На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).
	```
	 sudo opensnoop-bpfcc  -T
	TIME(s)       PID    COMM               FD ERR PATH
	0.000000000   755    vminfo              4   0 /var/run/utmp
	0.000661000   579    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
	0.001019000   579    dbus-daemon        18   0 /usr/share/dbus-1/system-services
	0.001442000   579    dbus-daemon        -1   2 /lib/dbus-1/system-services
	0.001509000   579    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/

	```
1. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.
	
	*Системный вызов `uname`*. Выдержка из  `man` 
	
	```
	Part of the utsname information is also accessible via
    /proc/sys/kernel/{ostype, hostname, osrelease, version,domainname}
	```
1. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
    Есть ли смысл использовать в bash `&&`, если применить `set -e`?
	
	*При разделении  с помощью `;` команды выполнятся последовательно, при `&&` каждая последующая команда выполнится только в случае нулевого  кода выхода предыдущей . При применении `set -e` осуществляется немедленный выход, если команда завершается кодом, отличным от нуля. В указанном контексте смысла использования `&&` при включенном `set -e` не вижу*
	
1. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?
   
   *Включение заданного режима позволяет избежать скрытых ошибок на этапе разработки bash сценария<br/>
   `set -e` - указывает bash немедленно выйти, если какая-либо команда имеет ненулевой статус выхода.<br/>
   `set -x` -включает режим оболочки, при котором все выполняемые команды выводятся на терминал<br/>
   `set -u` -если в каком-либо месте скрипта появляется неопределенная ранее переменная, то осуществляется немедленный выход.Правилом игнорируются переменные `$*`,`$@`<br/>
   `set -o pipefail` -этот параметр предотвращает маскировку ошибок в конвейере. Если какая-либо команда в конвейере терпит неудачу, то код выхода этой команды  будет использоваться как код выхода всего конвейера. По умолчанию код выхода конвейера - это код последней команды, даже если она выполнена успешно.
l*
1. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).


	*В колонке STAT  указывается статус процесса.В моем случае наиболее часто встречается статус `S`. Если кратко, статус определяет состояния процесса в данный момент. Основные статусы процессов:<br/>
    `R (Running)` – активный запущенный процесс, либо готов к  выполнению.<br/>
	`S (Sleeping)` – спящий процесс, процесс находится  состоянии ожидания, то есть ожидает какого-то события, сигнала либо же  освобождения нужного ресурса.<br/>
	`T` – приостановленный процесс или трассируется отладчиком.<br/>
	`Z (Zombie)` – убитый процесс, которого уже не существует, но соответствующие ему структуры ядра не освобождаются, это часто происходить когда родительский процесс завершился до получения сигнала о завершении от своего  дочернего процесса.<br/>
	`D (Direct)` – находится в состоянии непрерывного ожидания дискового ввода/вывода.<br/>
	Также эти состояния могут иметь дополнительный символы возле себя, которые добавляют к стандартным статусам некоторые особенности, например, часто можно встретить R+ или же Ss.<br/>
	знак `+` – указывает на приоритетность процесса.<br/>
	знак `s` – указывает, что это ведущий в сеансе процесс.<br/>*
 
 
